object FunctionalProgramming {
  def main(args: Array[String]): Unit = {
    
    /**
     * 1.函数可以直接赋值给变量；在使用的方法是有参数的情况下，但是赋值给变量时没写参数，可以使用“ _”来完成赋值。
     */
    //以下两种调用bigData方法的方式有什么区别？
    val Data = bigData("Scala")  //①
    val Data1 = bigData _  //②
    Data1("Scala1")
//------------------------------------------------------------------------------------------
    
    /**
     * 2.匿名函数的使用：
     * 	   一、创建匿名函数：    (name: String) => println("匿名函数：" + name)；
     * 	   二、 创建一个匿名函数；“=>”左边是这个函数的输入类型，“=>”右边是这个函数的输出类型/方法体。
     */
    //使用匿名函数：一般需要把这个匿名函数赋值给变量后进行使用
    val nm = (name: String) => println("使用匿名函数：" + name)
    nm("true")
//------------------------------------------------------------------------------------------
    
    /**
     * 3.函数可以直接作为参数传递给另一个函数进行使用
     * 		一、与java的对比：Java中的方式是new出一个接口实例，并在接口实例的回掉函数callback中实现业务逻辑；
     * 								 Scala中的方式是把回掉函数callback传递给函数，并在函数体中直接使用；
     * 		二、简便了编写业务逻辑和控制逻辑的代码；
     * 		三、“函数作为参数传递给函数”的这种编程方式称之为高阶函数的编程方式，Spark和应用程序开发中有60%都是这种代码。
     */
    def getName(func: String => Unit, name: String){
      
        /*func是“getName”方法的一个参数，而这个参数是上面的变量，而这个变量是匿名函数赋值给变量的，这个匿名函数设定的是需要传参的，所以在使用func这个参数的时候需要传入一个参数来调用变量使用这个
        	匿名函数*/
      func(name)  //这里传入name的目的是把这个name参数传入到上面的匿名函数中进行使用
    }
    getName(nm,"Scala")    
    /*
			执行顺序：调用getName方法并传入两个参数值（第一个参数是一个函数，第二个参数是“name”）  -->  getName方法体中调用参数func的函数方法并
                 传入getName方法的“name”参数   -->  结果返回getName方法体中的内容(方法体中只使用了变量名为“nm”的匿名函数，所以getName方法打印的结果就是
      “nm”传入参数所得的结果）
    */
   //延伸：
    Array(1 to 10: _*).map{(item: Int) => 2 * item}.foreach{ x => println(x)}
//------------------------------------------------------------------------------------------
    
    /**
     * 4.函数的返回值可以是函数：
     * 		一、当函数的返回类型是函数的时候，就表明Scala函数实现了闭包；
     * 		二、闭包原理：Scala函数的背后是类和对象，所以Scala的参数都作为了对象的成员，从而可以让后面的函数可以继续访问；
     * 
     * ①和②的过程不同，但所实现的结果是一样的；
     */
    def funcResult(message: String) = (name: String) => println(message + " ：" + name)//①   该函数的返回值也是一个函数，并且返回值可以访问funcResult的message参数
    funcResult("闭包：Scala")("Hello")    //①    这是Currying函数写法，复杂的Scala函数编程代码中一定会有这种写法
    
    val result = funcResult("普通：Hello")    //②    普通的Scala写法，调用funcResult后返回值是函数，所以需要再给这个返回值进行赋值才能使用
    result("Scala")    //②
    /**
     * Currying：复杂的函数式编程中经常会使用，其可以维护变量在内存中的状态，且实现返回函数的链式功能，能够实现非常复杂的算法和逻辑
     */
//------------------------------------------------------------------------------------------
    
  }
  
  def bigData(name: String){
    println("Hello, " + name)
  }
}
